serviceAccount:
  create: false
  name: ${k8s_service_account_name}
  annotations:
    %{ if cloud_provider == "gke" }iam.gke.io/gcp-service-account: ${gcp_service_account_email}%{ endif }
    %{ if cloud_provider == "eks" }eks.amazonaws.com/role-arn: ${aws_role_arn}%{ endif }

mimir:
  structuredConfig:
    multitenancy_enabled: false

    common:
      storage:
        backend: %{ if cloud_provider == "gke" }gcs%{ else }s3%{ endif }
        %{ if cloud_provider == "gke" }
        gcs:
          bucket_name: ${mimir_blocks_bucket}
        %{ else }
        s3:
          bucket_name: ${mimir_blocks_bucket}
          region: ${aws_region}
        %{ endif }
    
    blocks_storage:
      backend: %{ if cloud_provider == "gke" }gcs%{ else }s3%{ endif }
      %{ if cloud_provider == "gke" }
      gcs:
        bucket_name: ${mimir_blocks_bucket}
      %{ else }
      s3:
        bucket_name: ${mimir_blocks_bucket}
        region: ${aws_region}
      %{ endif }
      tsdb:
        dir: /data/mimir-data/tsdb
        retention_period: 720h
      bucket_store:
        sync_dir: /data/mimir-data/tsdb-sync
    
    alertmanager_storage:
      backend: %{ if cloud_provider == "gke" }gcs%{ else }s3%{ endif }
      %{ if cloud_provider == "gke" }
      gcs:
        bucket_name: ${mimir_ruler_bucket}
      %{ else }
      s3:
        bucket_name: ${mimir_ruler_bucket}
        region: ${aws_region}
      %{ endif }
    
    ruler_storage:
      backend: %{ if cloud_provider == "gke" }gcs%{ else }s3%{ endif }
      %{ if cloud_provider == "gke" }
      gcs:
        bucket_name: ${mimir_ruler_bucket}
      %{ else }
      s3:
        bucket_name: ${mimir_ruler_bucket}
        region: ${aws_region}
      %{ endif }
    
    server:
      log_level: info
    
    limits:
      ingestion_rate: 80000
      max_global_series_per_user: 0
    
    compactor:
      data_dir: /data/mimir-data/compactor
      compaction_interval: 30m
    
    ingester:
      ring:
        replication_factor: 1

distributor:
  replicas: 1
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi

ingester:
  replicas: 1
  persistentVolume:
    enabled: true
    size: 50Gi
    storageClass: standard-rwo
  resources:
    requests:
      cpu: 500m
      memory: 2Gi
    limits:
      cpu: 1
      memory: 3Gi  # Limit must be >= request, optimized for resource constraints
  zoneAwareReplication:
    enabled: false

querier:
  replicas: 1
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi

query_frontend:
  replicas: 1
  resources:
    requests:
      cpu: 200m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

store_gateway:
  replicas: 1
  persistentVolume:
    enabled: true
    size: 50Gi
    storageClass: standard-rwo
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 1
      memory: 2Gi  # Limit must be >= request
  zoneAwareReplication:
    enabled: false

compactor:
  replicas: 1
  persistentVolume:
    enabled: true
    size: 300Gi
    storageClass: standard-rwo
  resources:
    requests:
      cpu: 500m
      memory: 2Gi
    limits:
      cpu: 1
      memory: 3Gi  # Limit must be >= request, optimized for memory constraints

ruler:
  replicas: 0
  enabled: false

alertmanager:
  replicas: 0
  enabled: false

query_scheduler:
  replicas: 0
  enabled: false

overrides_exporter:
  replicas: 1

nginx:
  replicas: 1
  ingress:
    enabled: false
    ingressClassName: ${ingress_class_name}
    annotations:
      cert-manager.io/issuer: ${cert_issuer_name}
      external-dns.alpha.kubernetes.io/hostname: mimir.${monitoring_domain}

minio:
  enabled: false

memcached:
  enabled: false
memcached-queries:
  enabled: false
memcached-metadata:
  enabled: false
memcached-results:
  enabled: false

rollout_operator:
  enabled: false
